{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Hi Mike \u00b6 Hey nice - now let's start writing some documentation!","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#hi-mike","text":"Hey nice - now let's start writing some documentation!","title":"Hi Mike"},{"location":"Emmet/","text":"Emmet Commands \u00b6 HTML \u00b6 ! Will create a skeleton html page. ul>li\\*3#name$ < ul > < li id = \"name1\" ></ li > < li id = \"name2\" ></ li > < li id = \"name3\" ></ li > </ ul > CSS \u00b6 m10 margin : 10px ; p10 padding : 10px ; dn display : none ; React \u00b6 rcc Create a React class component rfc Create a stateless functional component impt inserts: import PropTypes from 'prop-types' Does not include the ending semi-colon; .item*3>label[for=\"dog$\"]{Dog }+input#dog }+input#dog < div className = \"item\" >< label htmlFor = \"dog1\" > Dog 1 </ label >< input type = \"text\" id = \"dog1\" /></ div > < div className = \"item\" >< label htmlFor = \"dog2\" > Dog 2 </ label >< input type = \"text\" id = \"dog2\" /></ div > < div className = \"item\" >< label htmlFor = \"dog3\" > Dog 3 </ label >< input type = \"text\" id = \"dog3\" /></ div > Javascript \u00b6 aja Will create a $.ajax({}) code block.","title":"Emmet Commands"},{"location":"Emmet/#emmet-commands","text":"","title":"Emmet Commands"},{"location":"Emmet/#html","text":"! Will create a skeleton html page. ul>li\\*3#name$ < ul > < li id = \"name1\" ></ li > < li id = \"name2\" ></ li > < li id = \"name3\" ></ li > </ ul >","title":"HTML"},{"location":"Emmet/#css","text":"m10 margin : 10px ; p10 padding : 10px ; dn display : none ;","title":"CSS"},{"location":"Emmet/#react","text":"rcc Create a React class component rfc Create a stateless functional component impt inserts: import PropTypes from 'prop-types' Does not include the ending semi-colon; .item*3>label[for=\"dog$\"]{Dog }+input#dog }+input#dog < div className = \"item\" >< label htmlFor = \"dog1\" > Dog 1 </ label >< input type = \"text\" id = \"dog1\" /></ div > < div className = \"item\" >< label htmlFor = \"dog2\" > Dog 2 </ label >< input type = \"text\" id = \"dog2\" /></ div > < div className = \"item\" >< label htmlFor = \"dog3\" > Dog 3 </ label >< input type = \"text\" id = \"dog3\" /></ div >","title":"React"},{"location":"Emmet/#javascript","text":"aja Will create a $.ajax({}) code block.","title":"Javascript"},{"location":"ImageTestDoc/","text":"Copy and Paste from clipboard \u00b6 did not name the doc or save or anything other than copy and paste Did that work ?","title":"Copy and Paste from clipboard"},{"location":"ImageTestDoc/#copy-and-paste-from-clipboard","text":"did not name the doc or save or anything other than copy and paste Did that work ?","title":"Copy and Paste from clipboard"},{"location":"MkDocs/","text":"MkDocs \u00b6 Static site generator used to build the MyDocs documentation site. Commit and push your changes first \u00b6 git add . git commit -m \"updated this doc\" git push origin master Deploy to GH Pages \u00b6 You must be in c:\\users\\jackie\\onedrive\\development\\docs\\ not ...docs\\docs\\ mkdocs gh-deploy Develop Your Site \u00b6 mkdocs serve Then open http://127.0.0.1:8000/ to see a live preview of your site. Create a New Documentation Project \u00b6 mkdocs new my-project cd my-project","title":"MkDocs"},{"location":"MkDocs/#mkdocs","text":"Static site generator used to build the MyDocs documentation site.","title":"MkDocs"},{"location":"MkDocs/#commit-and-push-your-changes-first","text":"git add . git commit -m \"updated this doc\" git push origin master","title":"Commit and push your changes first"},{"location":"MkDocs/#deploy-to-gh-pages","text":"You must be in c:\\users\\jackie\\onedrive\\development\\docs\\ not ...docs\\docs\\ mkdocs gh-deploy","title":"Deploy to GH Pages"},{"location":"MkDocs/#develop-your-site","text":"mkdocs serve Then open http://127.0.0.1:8000/ to see a live preview of your site.","title":"Develop Your Site"},{"location":"MkDocs/#create-a-new-documentation-project","text":"mkdocs new my-project cd my-project","title":"Create a New Documentation Project"},{"location":"RegEx/","text":"RegEx \u00b6 Characters \u00b6 Character Legend Example Sample Match \\d Most engines: one digit from 0 to 9 file_\\d\\d file_25 \\d .NET, Python 3: one Unicode digit in any script file_\\d\\d file_9\u0a69 \\w Most engines: \"word character\": ASCII letter, digit or underscore \\w-\\w\\w\\w A-b_1 \\w .Python 3: \"word character\": Unicode letter, ideogram, digit, or underscore \\w-\\w\\w\\w \u5b57-\u307e_\u06f3 \\w .NET: \"word character\": Unicode letter, ideogram, digit, or connector \\w-\\w\\w\\w \u5b57-\u307e\u203f\u06f3 \\s Most engines: \"whitespace character\": space, tab, newline, carriage return, vertical tab a\\sb\\sc a b c \\s .NET, Python 3, JavaScript: \"whitespace character\": any Unicode separator a\\sb\\sc a b c \\D One character that is not a digit as defined by your engine's \\d \\D\\D\\D ABC \\W One character that is not a word character as defined by your engine's \\w \\W\\W\\W\\W\\W *-+=) \\S One character that is not a whitespace character as defined by your engine's \\s \\S\\S\\S\\S Yoyo Quantifiers \u00b6 Quantifier Legend Example Sample Match + One or more Version \\w-\\w+ Version A-b1_1 {3} Exactly three times \\D{3} ABC {2,4} Two to four times \\d{2,4} 156 {3,} Three or more times \\w{3,} regex_tutorial * Zero or more times A*B*C* AAACC ? Once or none plurals? plural More Characters \u00b6 Character Legend Example Sample Match . Any character except line break a.c abc . Any character except line break .* whatever, man. * .* A period (special character: needs to be escaped by a ) a.c a.c \\ Escapes a special character .*+\\? $^\\/\\ .*+? $^/\\ \\ Escapes a special character [{()}] [{()}] Logic \u00b6 Logic Legend Example Sample Match | Alternation / OR operand 22|33 33 ( \u2026 ) Capturing group A(nt|pple) Apple (captures \"pple\") \\1 Contents of Group 1 r(\\w)g\\1x regex \\2 Contents of Group 2 (\\d\\d)+(\\d\\d)=\\2+\\1 12+65=65+12 (?: \u2026 ) Non-capturing group A(?:nt|pple) Apple More White-Space \u00b6 Character Legend Example Sample Match \\t Tab T\\t\\w{2} T ab \\r Carriage return character see below \\n Line feed character see below \\r\\n Line separator on Windows AB\\r\\nCD AB CD \\N Perl, PCRE (C, PHP, R\u2026): one character that is not a line break \\N+ ABC \\h Perl, PCRE (C, PHP, R\u2026), Java: one horizontal whitespace character: tab or Unicode space separator \\H One character that is not a horizontal whitespace \\v .NET, JavaScript, Python, Ruby: vertical tab \\v Perl, PCRE (C, PHP, R\u2026), Java: one vertical whitespace character: line feed, carriage return, vertical tab, form feed, paragraph or line separator \\V Perl, PCRE (C, PHP, R\u2026), Java: any character that is not a vertical whitespace \\R Perl, PCRE (C, PHP, R\u2026), Java: one line break (carriage return + line feed pair, and all the characters matched by \\v) More Quantifiers \u00b6 Quantifier Legend Example Sample Match + The + (one or more) is \"greedy\" \\d+ 12345 ? Makes quantifiers \"lazy\" \\d+? 1 in **1**2345 * The * (zero or more) is \"greedy\" A* AAA ? Makes quantifiers \"lazy\" A*? empty in AAA {2,4} Two to four times, \"greedy\" \\w{2,4} abcd ? Makes quantifiers \"lazy\" \\w{2,4}? ab in **ab**cd Character Classes \u00b6 Character Legend Example Sample Match [ \u2026 ] One of the characters in the brackets [AEIOU] One uppercase vowel [ \u2026 ] One of the characters in the brackets T[ao]p Tap or Top - Range indicator [a-z] One lowercase letter [x-y] One of the characters in the range from x to y [A-Z]+ GREAT [ \u2026 ] One of the characters in the brackets [AB1-5w-z] One of either: A,B,1,2,3,4,5,w,x,y,z [x-y] One of the characters in the range from x to y [\u2002-~]+ Characters in the printable section of the ASCII table . [^x] One character that is not x [^a-z]{3} A1! [^x-y] One of the characters not in the range from x to y [^\u2002-~]+ Characters that are not in the printable section of the ASCII table . [\\d\\D] One character that is a digit or a non-digit [\\d\\D]+ Any characters, inc- luding new lines, which the regular dot doesn't match [\\x41] Matches the character at hexadecimal position 41 in the ASCII table, i.e. A [\\x41-\\x45]{3} ABE Anchors and Boundaries \u00b6 Anchor Legend Example Sample Match ^ Start of string or start of line depending on multiline mode. (But when [^inside brackets], it means \"not\") ^abc .* abc (line start) $ End of string or end of line depending on multiline mode. Many engine-dependent subtleties. .*? the end$ this is the end \\A Beginning of string (all major engines except JS) \\Aabc[\\d\\D]* abc (string... ...start) \\z Very end of the string Not available in Python and JS the end\\z this is...\\n... the end \\Z End of string or (except Python) before final line break Not available in JS the end\\Z this is...\\n... the end \\n \\G Beginning of String or End of Previous Match .NET, Java, PCRE (C, PHP, R\u2026), Perl, Ruby \\b Word boundary Most engines: position where one side only is an ASCII letter, digit or underscore Bob.*\\bcat\\b Bob ate the cat \\b Word boundary .NET, Java, Python 3, Ruby: position where one side only is a Unicode letter, digit or underscore Bob.*\\b\\\u043a\u043e\u0448\u043a\u0430\\b Bob ate the \u043a\u043e\u0448\u043a\u0430 \\B Not a word boundary c. \\Bcat\\B. copycats Lookarounds \u00b6 Lookaround Legend Example Sample Match (?=\u2026) Positive lookahead (?=\\d{10})\\d{5} 01234 in **01234**56789 (?<=\u2026) Positive lookbehind (?<=\\d)cat cat in 1**cat** (?!\u2026) Negative lookahead (?!theatre)the\\w+ theme (?<!\u2026) Negative lookbehind \\w{3}(?<!mon)ster Munster Character Class Operations \u00b6 Class Operation Legend Example Sample Match [\u2026-[\u2026]] .NET: character class subtraction. One character that is in those on the left, but not in the subtracted class. [a-z-[aeiou]] Any lowercase consonant [\u2026-[\u2026]] .NET: character class subtraction. [\\p{IsArabic}-[\\D]] An Arabic character that is not a non-digit, i.e., an Arabic digit [\u2026&&[\u2026]] Java, Ruby 2+: character class intersection. One character that is both in those on the left and in the && class. [\\S&&[\\D]] An non-whitespace character that is a non-digit. [\u2026&&[\u2026]] Java, Ruby 2+: character class intersection. [\\S&&[\\D]&&[^a-zA-Z]] An non-whitespace character that a non-digit and not a letter. [\u2026&&[^\u2026]] Java, Ruby 2+: character class subtraction is obtained by intersecting a class with a negated class [a-z&&[^aeiou]] An English lowercase letter that is not a vowel. [\u2026&&[^\u2026]] Java, Ruby 2+: character class subtraction [\\p{InArabic}&&[^\\p{L}\\p{N}]] An Arabic character that is not a letter or a number","title":"RegEx"},{"location":"RegEx/#regex","text":"","title":"RegEx"},{"location":"RegEx/#characters","text":"Character Legend Example Sample Match \\d Most engines: one digit from 0 to 9 file_\\d\\d file_25 \\d .NET, Python 3: one Unicode digit in any script file_\\d\\d file_9\u0a69 \\w Most engines: \"word character\": ASCII letter, digit or underscore \\w-\\w\\w\\w A-b_1 \\w .Python 3: \"word character\": Unicode letter, ideogram, digit, or underscore \\w-\\w\\w\\w \u5b57-\u307e_\u06f3 \\w .NET: \"word character\": Unicode letter, ideogram, digit, or connector \\w-\\w\\w\\w \u5b57-\u307e\u203f\u06f3 \\s Most engines: \"whitespace character\": space, tab, newline, carriage return, vertical tab a\\sb\\sc a b c \\s .NET, Python 3, JavaScript: \"whitespace character\": any Unicode separator a\\sb\\sc a b c \\D One character that is not a digit as defined by your engine's \\d \\D\\D\\D ABC \\W One character that is not a word character as defined by your engine's \\w \\W\\W\\W\\W\\W *-+=) \\S One character that is not a whitespace character as defined by your engine's \\s \\S\\S\\S\\S Yoyo","title":"Characters"},{"location":"RegEx/#quantifiers","text":"Quantifier Legend Example Sample Match + One or more Version \\w-\\w+ Version A-b1_1 {3} Exactly three times \\D{3} ABC {2,4} Two to four times \\d{2,4} 156 {3,} Three or more times \\w{3,} regex_tutorial * Zero or more times A*B*C* AAACC ? Once or none plurals? plural","title":"Quantifiers"},{"location":"RegEx/#more-characters","text":"Character Legend Example Sample Match . Any character except line break a.c abc . Any character except line break .* whatever, man. * .* A period (special character: needs to be escaped by a ) a.c a.c \\ Escapes a special character .*+\\? $^\\/\\ .*+? $^/\\ \\ Escapes a special character [{()}] [{()}]","title":"More Characters"},{"location":"RegEx/#logic","text":"Logic Legend Example Sample Match | Alternation / OR operand 22|33 33 ( \u2026 ) Capturing group A(nt|pple) Apple (captures \"pple\") \\1 Contents of Group 1 r(\\w)g\\1x regex \\2 Contents of Group 2 (\\d\\d)+(\\d\\d)=\\2+\\1 12+65=65+12 (?: \u2026 ) Non-capturing group A(?:nt|pple) Apple","title":"Logic"},{"location":"RegEx/#more-white-space","text":"Character Legend Example Sample Match \\t Tab T\\t\\w{2} T ab \\r Carriage return character see below \\n Line feed character see below \\r\\n Line separator on Windows AB\\r\\nCD AB CD \\N Perl, PCRE (C, PHP, R\u2026): one character that is not a line break \\N+ ABC \\h Perl, PCRE (C, PHP, R\u2026), Java: one horizontal whitespace character: tab or Unicode space separator \\H One character that is not a horizontal whitespace \\v .NET, JavaScript, Python, Ruby: vertical tab \\v Perl, PCRE (C, PHP, R\u2026), Java: one vertical whitespace character: line feed, carriage return, vertical tab, form feed, paragraph or line separator \\V Perl, PCRE (C, PHP, R\u2026), Java: any character that is not a vertical whitespace \\R Perl, PCRE (C, PHP, R\u2026), Java: one line break (carriage return + line feed pair, and all the characters matched by \\v)","title":"More White-Space"},{"location":"RegEx/#more-quantifiers","text":"Quantifier Legend Example Sample Match + The + (one or more) is \"greedy\" \\d+ 12345 ? Makes quantifiers \"lazy\" \\d+? 1 in **1**2345 * The * (zero or more) is \"greedy\" A* AAA ? Makes quantifiers \"lazy\" A*? empty in AAA {2,4} Two to four times, \"greedy\" \\w{2,4} abcd ? Makes quantifiers \"lazy\" \\w{2,4}? ab in **ab**cd","title":"More Quantifiers"},{"location":"RegEx/#character-classes","text":"Character Legend Example Sample Match [ \u2026 ] One of the characters in the brackets [AEIOU] One uppercase vowel [ \u2026 ] One of the characters in the brackets T[ao]p Tap or Top - Range indicator [a-z] One lowercase letter [x-y] One of the characters in the range from x to y [A-Z]+ GREAT [ \u2026 ] One of the characters in the brackets [AB1-5w-z] One of either: A,B,1,2,3,4,5,w,x,y,z [x-y] One of the characters in the range from x to y [\u2002-~]+ Characters in the printable section of the ASCII table . [^x] One character that is not x [^a-z]{3} A1! [^x-y] One of the characters not in the range from x to y [^\u2002-~]+ Characters that are not in the printable section of the ASCII table . [\\d\\D] One character that is a digit or a non-digit [\\d\\D]+ Any characters, inc- luding new lines, which the regular dot doesn't match [\\x41] Matches the character at hexadecimal position 41 in the ASCII table, i.e. A [\\x41-\\x45]{3} ABE","title":"Character Classes"},{"location":"RegEx/#anchors-and-boundaries","text":"Anchor Legend Example Sample Match ^ Start of string or start of line depending on multiline mode. (But when [^inside brackets], it means \"not\") ^abc .* abc (line start) $ End of string or end of line depending on multiline mode. Many engine-dependent subtleties. .*? the end$ this is the end \\A Beginning of string (all major engines except JS) \\Aabc[\\d\\D]* abc (string... ...start) \\z Very end of the string Not available in Python and JS the end\\z this is...\\n... the end \\Z End of string or (except Python) before final line break Not available in JS the end\\Z this is...\\n... the end \\n \\G Beginning of String or End of Previous Match .NET, Java, PCRE (C, PHP, R\u2026), Perl, Ruby \\b Word boundary Most engines: position where one side only is an ASCII letter, digit or underscore Bob.*\\bcat\\b Bob ate the cat \\b Word boundary .NET, Java, Python 3, Ruby: position where one side only is a Unicode letter, digit or underscore Bob.*\\b\\\u043a\u043e\u0448\u043a\u0430\\b Bob ate the \u043a\u043e\u0448\u043a\u0430 \\B Not a word boundary c. \\Bcat\\B. copycats","title":"Anchors and Boundaries"},{"location":"RegEx/#lookarounds","text":"Lookaround Legend Example Sample Match (?=\u2026) Positive lookahead (?=\\d{10})\\d{5} 01234 in **01234**56789 (?<=\u2026) Positive lookbehind (?<=\\d)cat cat in 1**cat** (?!\u2026) Negative lookahead (?!theatre)the\\w+ theme (?<!\u2026) Negative lookbehind \\w{3}(?<!mon)ster Munster","title":"Lookarounds"},{"location":"RegEx/#character-class-operations","text":"Class Operation Legend Example Sample Match [\u2026-[\u2026]] .NET: character class subtraction. One character that is in those on the left, but not in the subtracted class. [a-z-[aeiou]] Any lowercase consonant [\u2026-[\u2026]] .NET: character class subtraction. [\\p{IsArabic}-[\\D]] An Arabic character that is not a non-digit, i.e., an Arabic digit [\u2026&&[\u2026]] Java, Ruby 2+: character class intersection. One character that is both in those on the left and in the && class. [\\S&&[\\D]] An non-whitespace character that is a non-digit. [\u2026&&[\u2026]] Java, Ruby 2+: character class intersection. [\\S&&[\\D]&&[^a-zA-Z]] An non-whitespace character that a non-digit and not a letter. [\u2026&&[^\u2026]] Java, Ruby 2+: character class subtraction is obtained by intersecting a class with a negated class [a-z&&[^aeiou]] An English lowercase letter that is not a vowel. [\u2026&&[^\u2026]] Java, Ruby 2+: character class subtraction [\\p{InArabic}&&[^\\p{L}\\p{N}]] An Arabic character that is not a letter or a number","title":"Character Class Operations"},{"location":"JavaScript/loops/","text":"Loops in JavaScript \u00b6 Author: Lilian Lin Original Medium Article Loops in JavaScript means a chunk of codes executed repeatedly in certain amount. For example, if we want to print \u201cHello\u201d in console for 5 times, we can write the following statements: console.log('Hello'); console.log('Hello'); console.log('Hello'); console.log('Hello'); console.log('Hello'); for\u2026loop \u00b6 Seems like too much. This is the time when loops jump in. Just need to write the statement one time, give it a condition, then the statement can be executed repeatedly while the condition evaluates to true. for(let i = 0; i < 5; i++){ console.log('Hello'); } for loops is the most basic one in JavaScript, we can see it as a counter. It requires 3 statements in parenthesis: Initialize the counter: let i=0 (the counter starts from 0) . Condition, which tells the for loop when to stop: i < 5 (when i reaches 5, the condition evaluates to false, the loop stops running). Increment or Decrement the counting: i++ (starts from 0, each time increase 1. if you use\u200a\u2014\u200a\u2014 , then the counter will decrease 1). So each time computer will evaluate if the variable\u2019s current value passes condition. If it is, run the code inside. If it\u2019s not, stop the loops. // i = 0 i<5? true 'Hello' i++ => i = 1 i<5? true 'Hello' i++ => i = 2 i<5? true 'Hello' i++ => i = 3 i<5? true 'Hello' i++ => i = 4 i<5? true 'Hello' i++ => i = 5 i<5? false stop counting! for loops are also often used on array: const arr = ['H', 'E', 'L', 'L', 'O']; for(let i = 0; i < arr.length; i++){ console.log(arr[i]); } //in console will print: H // i = 0, i < 5?true, i++, print arr[0] E // i = 1, i < 5?true, i++, print arr[1] L // i = 2, i < 5?true, i++, print arr[2] L // i = 3, i < 5?true, i++, print arr[3] O // i = 4, i < 5?true, i++, print arr[4] // i = 5, i = arr.length false, stop for\u2026of loops \u00b6 There is also another loop that can iterate through an array. And with this one, you don\u2019t need to create index variables. Once reaches the end of the array, it will stop looping automatically: for(let val of arr){ console.log(val); } //in console will print: H E L L O // this is the last item in arr, stop looping. But for\u2026of loops only works with iterable values. So it can not be used on objects. for\u2026in loops \u00b6 This loop becomes very handy when working with objects. Imagine if you want to print a grocery list, but you are not sure how many items are in this list, so just iterating through it, and print them all. const grocery = { 1: 'apple', 2: 'banana', 3: 'milk', 4: 'bread', 5: 'chicken', 6: 'pasta' } for(let item in grocery){ console.log(item); } //in console will print: apple banana milk bread chicken pasta // this is the last item in grocery object, stop looping. while loops \u00b6 Then how about we want looping for infinite times and break automatically under certain conditions. This is when while loops jump in: let num = 5; while(num<200){ console.log(num); num = num*5; } //in console will print: 5 // num = 5, num < 200? true, print num, num*5 25 // num = 25, num < 200? true, print num, num*5 125 // num = 125, num < 200? true, print num, num*5 // num = 625, num < 200? false, stop looping As we can see. The condition is evaluated before the statement in the loop is executed. If the condition returns true, the statement is executed and the condition is evaluated again. If the condition returns false, the statement will be stop executing. do\u2026while loops \u00b6 But sometimes we are not sure about what the condition will be returned. In case nothing is executing (the condition evaluates to false at the beginning), we can use do\u2026while loops. let num = 200; do { console.log(num); } while(num++ < 200) //in console will print: 201 // num++ = 201; num++ < 200? false stop looping Have you noticed what\u2019s the difference? do\u2026while loops evaluate its condition after the execution of the given statement in the loop. So even though the condition returns false at the beginning of iterate, the statement will be executed at least once . When we started learning for loops , we usually use it on arrays. However array as the \u2018most iterable\u2019 object, instead of passing it into for loops, we can also make use of build-in array method that offers more straight forward syntax to reach different goals. I\u2019d like to put those methods in two kinds: iterate without returning a new array. iterate and create a new array. array.forEach() \u00b6 It will execute a function on every item in the array. No new array will be returned . forEach method will take a function as its argument. When the function starts iterating, it will have access to three things about current item: value* ,* index* ,***object.** const grocery = ['apple','banana','milk','bread','chicken'] grocery.forEach(function(value, index, object){ console.log(value, index, object); }) //in console will print: apple 0 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] banana 1 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] milk 2 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] bread 3 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] chicken 4 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] pasta 5 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] But usually we just need the value argument to work on, and arrow function will make such method a cleaner syntax. grocery.forEach(value => console.log(value)) //in console will print: apple banana milk bread chicken pasta array.find() \u00b6 It will take a condition in the provided function, and return the first element**that passes the condition. If nothing fulfills the condition, **undefined will be returned. const num = [1,2,3,4,5,6]; let smallNum = num.find(item => item < 3); let bigNum = num.find(item => item > 6); console.log(smallNum, bigNum); //in console will print: 1 undefined // though 1,2 are both < 3, 1 is the first value passed the test, so only 1 is returned. // no value in the num array is > 6, so undefined is returned. array.findIndex() \u00b6 This method is similar with the .find() method, the only difference is that it returns the index of the first element that pass the condition. If no item passes the test, it returns -1 . const num = [1,2,3,4,5,6]; let smallIndex = num.findIndex(item => item < 3); let bigIndex = num.findIndex(item => item > 6); console.log(smallIndex, bigIndex); //in console will print: 0 -1 array.some() \u00b6 This method also takes a condition given by the function. It checks if any**elements in the array pass the condition (**at least one ). It returns true / false . const num = [1,2,3,4,5,6]; let isSmall = num.some(item => item < 3); let isBig = num.some(item => item > 6); console.log(isSmall, isBig); //in console will print: true false array.every() \u00b6 It checks whether all elements in the array pass the condition. It returns true / false . const num = [1,2,3,4,5,6]; let areSmall = num.every(item => item < 3); let areBig = num.every(item => item > 6); console.log(areSmall, areBig); //in console will print: false false array.reduce() \u00b6 This is a really helpful and \u2018fancy\u2019 method. It executes a provided function on each element of the array, and reduce the value of the array to a single value . The provided function must take two parameters: \\1. accumulator : it accumulates the returned value. \\2. currentValue : the element being processed in the array. const num = [1,2,3,4,5,6]; let sum = num.reduce((accumulator, currentValue) => { return accumulator + currentValue; }) console.log(sum); // accumulator = 1, currentValue = 2, return 3 accumulator = 3, currentValue = 3, return 6 accumulator = 6, currentValue = 4, return 10 accumulator = 10, currentValue = 5, return 15 accumulator = 15, currentValue = 6, return 21 //in console will print: 21 array.reduceRight() \u00b6 It works exactly the same as .reduce() method, the only difference is it iterates an array backwards, from right to the left side. const newNum = [1,10,100,1000]; let minus= newNum.reduceRight((accumulator, currentValue) => { return accumulator - currentValue; }) console.log(minus); // accumulator = 1000, currentValue = 100, return 900 accumulator = 900, currentValue = 10, return 890 accumulator = 890, currentValue = 1, return 889 //in console will print: 889 All the iterating methods above do not return a new array. But there are times we need our input data immutable, which means a new array should be created from the existing array. For example, in React Redux, we have to work on new datas, and the original data can not be mutated. So let\u2019s talk about the second type: array.map() \u00b6 This method is similar with forEach(), which executes the given function on each item in the current array. And it creates a new array with the result of the provided function. const num = [1,2,3,4,5,6]; let multiply = num.map(value => value * 2); console.log(multiply); //in console will print: [2, 4, 6, 8, 10, 12] array.filter() \u00b6 This method takes a condition in the provided function, and iterates through the array to check if each element passes the condition. Then it will create a new array with all the elements that passed the condition. If none of the elements pass the condition, an empty array is created.This method is useful when you need to find one or more items based on a condition you create. const num = [1,2,3,4,5,6]; let smallNums = num.filter(item => item < 3); let bigNums = num.filter(item => item > 6); console.log(smallNums, bigNums); //in console will print: [1,2] [] We\u2019ve covered different loop functions above. But how do we choose which to use? Below are my own rules of thumbs: Following the functional programming practices, given an array, we don\u2019t want to mutate the original array, so definitely consider array method: like map(), filter(). If we simply want to iterate an array, array methods like forEach() can usually do what we want. forEach() can take a callback function with an arity of three and you can pass the element index to it. If we want to iterate through all keys of an object, consider for\u2026in loops. If we want your statement run at least once, use do\u2026while. If any of above is not what we want, for loop always a fallback choice for us to customize our functions and conditions. Above are my personal preferences about using loops in Javascript. In reality, situations are more complicated and nuanced, and require our judgement and team agreements to write the looping code. Don\u2019t forget, the ultimate goal is to make our code expressive, so that it\u2019s easy to read and maintain. Using loops in JavaScript is like riding a rollercoaster, it seems to have a lot of different types. But no matter how it changes, the main idea never changes\u200a\u2014\u200aiterate&run. Enjoy your rides!","title":"Loops in JavaScript"},{"location":"JavaScript/loops/#loops-in-javascript","text":"Author: Lilian Lin Original Medium Article Loops in JavaScript means a chunk of codes executed repeatedly in certain amount. For example, if we want to print \u201cHello\u201d in console for 5 times, we can write the following statements: console.log('Hello'); console.log('Hello'); console.log('Hello'); console.log('Hello'); console.log('Hello');","title":"Loops in JavaScript"},{"location":"JavaScript/loops/#forloop","text":"Seems like too much. This is the time when loops jump in. Just need to write the statement one time, give it a condition, then the statement can be executed repeatedly while the condition evaluates to true. for(let i = 0; i < 5; i++){ console.log('Hello'); } for loops is the most basic one in JavaScript, we can see it as a counter. It requires 3 statements in parenthesis: Initialize the counter: let i=0 (the counter starts from 0) . Condition, which tells the for loop when to stop: i < 5 (when i reaches 5, the condition evaluates to false, the loop stops running). Increment or Decrement the counting: i++ (starts from 0, each time increase 1. if you use\u200a\u2014\u200a\u2014 , then the counter will decrease 1). So each time computer will evaluate if the variable\u2019s current value passes condition. If it is, run the code inside. If it\u2019s not, stop the loops. // i = 0 i<5? true 'Hello' i++ => i = 1 i<5? true 'Hello' i++ => i = 2 i<5? true 'Hello' i++ => i = 3 i<5? true 'Hello' i++ => i = 4 i<5? true 'Hello' i++ => i = 5 i<5? false stop counting! for loops are also often used on array: const arr = ['H', 'E', 'L', 'L', 'O']; for(let i = 0; i < arr.length; i++){ console.log(arr[i]); } //in console will print: H // i = 0, i < 5?true, i++, print arr[0] E // i = 1, i < 5?true, i++, print arr[1] L // i = 2, i < 5?true, i++, print arr[2] L // i = 3, i < 5?true, i++, print arr[3] O // i = 4, i < 5?true, i++, print arr[4] // i = 5, i = arr.length false, stop","title":"for\u2026loop"},{"location":"JavaScript/loops/#forof-loops","text":"There is also another loop that can iterate through an array. And with this one, you don\u2019t need to create index variables. Once reaches the end of the array, it will stop looping automatically: for(let val of arr){ console.log(val); } //in console will print: H E L L O // this is the last item in arr, stop looping. But for\u2026of loops only works with iterable values. So it can not be used on objects.","title":"for\u2026of loops"},{"location":"JavaScript/loops/#forin-loops","text":"This loop becomes very handy when working with objects. Imagine if you want to print a grocery list, but you are not sure how many items are in this list, so just iterating through it, and print them all. const grocery = { 1: 'apple', 2: 'banana', 3: 'milk', 4: 'bread', 5: 'chicken', 6: 'pasta' } for(let item in grocery){ console.log(item); } //in console will print: apple banana milk bread chicken pasta // this is the last item in grocery object, stop looping.","title":"for\u2026in loops"},{"location":"JavaScript/loops/#while-loops","text":"Then how about we want looping for infinite times and break automatically under certain conditions. This is when while loops jump in: let num = 5; while(num<200){ console.log(num); num = num*5; } //in console will print: 5 // num = 5, num < 200? true, print num, num*5 25 // num = 25, num < 200? true, print num, num*5 125 // num = 125, num < 200? true, print num, num*5 // num = 625, num < 200? false, stop looping As we can see. The condition is evaluated before the statement in the loop is executed. If the condition returns true, the statement is executed and the condition is evaluated again. If the condition returns false, the statement will be stop executing.","title":"while loops"},{"location":"JavaScript/loops/#dowhile-loops","text":"But sometimes we are not sure about what the condition will be returned. In case nothing is executing (the condition evaluates to false at the beginning), we can use do\u2026while loops. let num = 200; do { console.log(num); } while(num++ < 200) //in console will print: 201 // num++ = 201; num++ < 200? false stop looping Have you noticed what\u2019s the difference? do\u2026while loops evaluate its condition after the execution of the given statement in the loop. So even though the condition returns false at the beginning of iterate, the statement will be executed at least once . When we started learning for loops , we usually use it on arrays. However array as the \u2018most iterable\u2019 object, instead of passing it into for loops, we can also make use of build-in array method that offers more straight forward syntax to reach different goals. I\u2019d like to put those methods in two kinds: iterate without returning a new array. iterate and create a new array.","title":"do\u2026while loops"},{"location":"JavaScript/loops/#arrayforeach","text":"It will execute a function on every item in the array. No new array will be returned . forEach method will take a function as its argument. When the function starts iterating, it will have access to three things about current item: value* ,* index* ,***object.** const grocery = ['apple','banana','milk','bread','chicken'] grocery.forEach(function(value, index, object){ console.log(value, index, object); }) //in console will print: apple 0 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] banana 1 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] milk 2 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] bread 3 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] chicken 4 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] pasta 5 (5) [\"apple\", \"banana\", \"milk\", \"bread\", \"chicken\"] But usually we just need the value argument to work on, and arrow function will make such method a cleaner syntax. grocery.forEach(value => console.log(value)) //in console will print: apple banana milk bread chicken pasta","title":"array.forEach()"},{"location":"JavaScript/loops/#arrayfind","text":"It will take a condition in the provided function, and return the first element**that passes the condition. If nothing fulfills the condition, **undefined will be returned. const num = [1,2,3,4,5,6]; let smallNum = num.find(item => item < 3); let bigNum = num.find(item => item > 6); console.log(smallNum, bigNum); //in console will print: 1 undefined // though 1,2 are both < 3, 1 is the first value passed the test, so only 1 is returned. // no value in the num array is > 6, so undefined is returned.","title":"array.find()"},{"location":"JavaScript/loops/#arrayfindindex","text":"This method is similar with the .find() method, the only difference is that it returns the index of the first element that pass the condition. If no item passes the test, it returns -1 . const num = [1,2,3,4,5,6]; let smallIndex = num.findIndex(item => item < 3); let bigIndex = num.findIndex(item => item > 6); console.log(smallIndex, bigIndex); //in console will print: 0 -1","title":"array.findIndex()"},{"location":"JavaScript/loops/#arraysome","text":"This method also takes a condition given by the function. It checks if any**elements in the array pass the condition (**at least one ). It returns true / false . const num = [1,2,3,4,5,6]; let isSmall = num.some(item => item < 3); let isBig = num.some(item => item > 6); console.log(isSmall, isBig); //in console will print: true false","title":"array.some()"},{"location":"JavaScript/loops/#arrayevery","text":"It checks whether all elements in the array pass the condition. It returns true / false . const num = [1,2,3,4,5,6]; let areSmall = num.every(item => item < 3); let areBig = num.every(item => item > 6); console.log(areSmall, areBig); //in console will print: false false","title":"array.every()"},{"location":"JavaScript/loops/#arrayreduce","text":"This is a really helpful and \u2018fancy\u2019 method. It executes a provided function on each element of the array, and reduce the value of the array to a single value . The provided function must take two parameters: \\1. accumulator : it accumulates the returned value. \\2. currentValue : the element being processed in the array. const num = [1,2,3,4,5,6]; let sum = num.reduce((accumulator, currentValue) => { return accumulator + currentValue; }) console.log(sum); // accumulator = 1, currentValue = 2, return 3 accumulator = 3, currentValue = 3, return 6 accumulator = 6, currentValue = 4, return 10 accumulator = 10, currentValue = 5, return 15 accumulator = 15, currentValue = 6, return 21 //in console will print: 21","title":"array.reduce()"},{"location":"JavaScript/loops/#arrayreduceright","text":"It works exactly the same as .reduce() method, the only difference is it iterates an array backwards, from right to the left side. const newNum = [1,10,100,1000]; let minus= newNum.reduceRight((accumulator, currentValue) => { return accumulator - currentValue; }) console.log(minus); // accumulator = 1000, currentValue = 100, return 900 accumulator = 900, currentValue = 10, return 890 accumulator = 890, currentValue = 1, return 889 //in console will print: 889 All the iterating methods above do not return a new array. But there are times we need our input data immutable, which means a new array should be created from the existing array. For example, in React Redux, we have to work on new datas, and the original data can not be mutated. So let\u2019s talk about the second type:","title":"array.reduceRight()"},{"location":"JavaScript/loops/#arraymap","text":"This method is similar with forEach(), which executes the given function on each item in the current array. And it creates a new array with the result of the provided function. const num = [1,2,3,4,5,6]; let multiply = num.map(value => value * 2); console.log(multiply); //in console will print: [2, 4, 6, 8, 10, 12]","title":"array.map()"},{"location":"JavaScript/loops/#arrayfilter","text":"This method takes a condition in the provided function, and iterates through the array to check if each element passes the condition. Then it will create a new array with all the elements that passed the condition. If none of the elements pass the condition, an empty array is created.This method is useful when you need to find one or more items based on a condition you create. const num = [1,2,3,4,5,6]; let smallNums = num.filter(item => item < 3); let bigNums = num.filter(item => item > 6); console.log(smallNums, bigNums); //in console will print: [1,2] [] We\u2019ve covered different loop functions above. But how do we choose which to use? Below are my own rules of thumbs: Following the functional programming practices, given an array, we don\u2019t want to mutate the original array, so definitely consider array method: like map(), filter(). If we simply want to iterate an array, array methods like forEach() can usually do what we want. forEach() can take a callback function with an arity of three and you can pass the element index to it. If we want to iterate through all keys of an object, consider for\u2026in loops. If we want your statement run at least once, use do\u2026while. If any of above is not what we want, for loop always a fallback choice for us to customize our functions and conditions. Above are my personal preferences about using loops in Javascript. In reality, situations are more complicated and nuanced, and require our judgement and team agreements to write the looping code. Don\u2019t forget, the ultimate goal is to make our code expressive, so that it\u2019s easy to read and maintain. Using loops in JavaScript is like riding a rollercoaster, it seems to have a lot of different types. But no matter how it changes, the main idea never changes\u200a\u2014\u200aiterate&run. Enjoy your rides!","title":"array.filter()"},{"location":"React/ControlledInput/","text":"Controlled Input \u00b6 The standard method for dealing with input fields is to use a 'controlled input.' A controlled input is one in which the onChange event grabs the input, stores it to state then rerenders the component with the new value. Probably better with an example. Uncontrolled Input \u00b6 This is not recommended in React. Class SearchBar extends React . Component { onInputChange ( e ) { console . log ( e . target . value ); } render () { return ( < div > < form > < div > < label > Image Search < /label> < input type = \"text\" onChange = { this . onInputChange } /> < /div> < /form> < /div> ); } } Controlled Input \u00b6 The recommended method: Class SearchBar extends React . Component { constructor ( props ) { super ( props ); this . state = { term : '' }; } render () { return ( < div > < form > < div > < label > Image Search < /label> < input type = \"text\" value = { this . state . term } onChange = { e => this . setState ({ term : e . target . value }) } /> < /div> < /form> < /div> ); } } You could obviously still have the onChange call a separately defined method if needed. ... onInputChange = ( e ) => { // use an arrow function or bind 'this' in the constructor console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = { this . onInputChange } /> ... With bind in the constructor constructor ( props ) { super ( props ); this . onInputChange = this . onInputChange . bind ( this ); } onInputChange ( e ) { console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = { this . onInputChange } /> ... With an arrow function in the call onInputChange ( e ) { console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = {( e ) => this . onInputChange ( e )} /> ... You can bind in line also but not considered a best practice ... onInputChange ( e ) { console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = { this . onInputChange . bind ( this )} /> ...","title":"Controlled Input"},{"location":"React/ControlledInput/#controlled-input","text":"The standard method for dealing with input fields is to use a 'controlled input.' A controlled input is one in which the onChange event grabs the input, stores it to state then rerenders the component with the new value. Probably better with an example.","title":"Controlled Input"},{"location":"React/ControlledInput/#uncontrolled-input","text":"This is not recommended in React. Class SearchBar extends React . Component { onInputChange ( e ) { console . log ( e . target . value ); } render () { return ( < div > < form > < div > < label > Image Search < /label> < input type = \"text\" onChange = { this . onInputChange } /> < /div> < /form> < /div> ); } }","title":"Uncontrolled Input"},{"location":"React/ControlledInput/#controlled-input_1","text":"The recommended method: Class SearchBar extends React . Component { constructor ( props ) { super ( props ); this . state = { term : '' }; } render () { return ( < div > < form > < div > < label > Image Search < /label> < input type = \"text\" value = { this . state . term } onChange = { e => this . setState ({ term : e . target . value }) } /> < /div> < /form> < /div> ); } } You could obviously still have the onChange call a separately defined method if needed. ... onInputChange = ( e ) => { // use an arrow function or bind 'this' in the constructor console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = { this . onInputChange } /> ... With bind in the constructor constructor ( props ) { super ( props ); this . onInputChange = this . onInputChange . bind ( this ); } onInputChange ( e ) { console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = { this . onInputChange } /> ... With an arrow function in the call onInputChange ( e ) { console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = {( e ) => this . onInputChange ( e )} /> ... You can bind in line also but not considered a best practice ... onInputChange ( e ) { console . log ( e . target . value ); } ... < input type = \"text\" value = { this . state . term } onChange = { this . onInputChange . bind ( this )} /> ...","title":"Controlled Input"},{"location":"React/DocWorkFlowSettings/","text":"Documentation Work Flow Settings \u00b6 Set the When Insert Local Image> check the option Set the Global Image Settings... as follows:","title":"Documentation Work Flow Settings"},{"location":"React/DocWorkFlowSettings/#documentation-work-flow-settings","text":"Set the When Insert Local Image> check the option Set the Global Image Settings... as follows:","title":"Documentation Work Flow Settings"},{"location":"React/SubFile/","text":"test of file in sub folder \u00b6 Set the When Insert Local Image> check the option Set the Global Image Settings... as follows:","title":"test of file in sub folder"},{"location":"React/SubFile/#test-of-file-in-sub-folder","text":"Set the When Insert Local Image> check the option Set the Global Image Settings... as follows:","title":"test of file in sub folder"},{"location":"React/SubSub/ImageTestDocInSubSub/","text":"Copy and Paste from clipboard \u00b6 did not name the doc or save or anything other than copy and paste just a subsub document with no images Did that work ?","title":"Copy and Paste from clipboard"},{"location":"React/SubSub/ImageTestDocInSubSub/#copy-and-paste-from-clipboard","text":"did not name the doc or save or anything other than copy and paste just a subsub document with no images Did that work ?","title":"Copy and Paste from clipboard"}]}